## Параллельная секция в OpenMP. Параметры, указываемые при создании параллельной секции. Режимы инициализации и сохранения приватных переменных в параллельной секции. Методы разделения кода для исполнения разными потоками в OpenMP: `sections`, `single`, `master`, `task`.

В начале работы программы существует одна «основная» нить. Последовательные участки программы выполняет только основная нить и никакая другая. При входе в параллельную часть программы создаются новые «рабочие» нити, которые уничтожаются при выходе из параллельной части программы.

Директива `parallel`.

* Параллельные области являются основным понятием в OpenMP. Именно там, где задана эта область, программа исполняется параллельно. Как только компилятор встречает `#pragma omp parallel`, он вставляет инструкции для создания параллельных потоков. Синтаксис:

  ```C++
  #pragma omp parallel [clause[ [ , ] clause] ... ]
    structured-block
  ```

* Здесь `clause` — это:
  * `if(scalar-expression)` — выполнение параллельной области по условию. Вхождение в параллельную область осуществляется только при выполнении некоторого условия. Если условие не выполнено, то директива не срабатывает и продолжается обработка программы в прежнем режиме;
  * `num_threads(integer-expression)` — явное задание количества потоков, которые будут выполнять параллельную область; по умолчанию выбирается последнее значение, установленное  помощью функции `omp_set_num_threads()`, или значение переменной `OMP_NUM_THREADS`;
  * `default(shared | none)` — всем переменным в параллельной области, которым явно не назначен класс, будет назначен класс `shared`; `none` означает, что всем переменным в параллельной области класс должен быть назначен явно;
  * `private(list)` — задает список переменных, для которых порождается локальная копия в каждом потоке; начальное значение локальных копий переменных из списка не определено;
  * `firstprivate(list)` — задает список переменных, для которых порождается локальная копия в каждом потоке; локальные копии переменных инициализируются значениями этих переменных в потоке-мастере;
  * `shared(list)` — задает список переменных, общий для всех потоков;
  * `copyin(list)` — задает список переменных, объявленных как `threadprivate`, которые при входе в параллельную область инициализируются значениями соответствующих переменных в потоке-мастере;
  * `reduction(reduction-identifier : list)` — задает оператор и список общих переменных; для каждой переменной создаются локальные копии в каждом потоке; локальные копии инициализируются соответственно типу оператора; над локальными копиями перменных после завершения всех секций выполняется заданный оператор;
  * `proc_bind(master | close | spread)` — определяет способ привязки потоков в параллельной области.

Директива `sections`.

* Директива `sections` используется для задания конечного (неитеративного) параллелизма. Эта директива определяет набор независимых секций кода, каждая из которых выполняется своим потоком. Директива `section` задает участок кода внутри секции `sections` для выполнения одним потоком. Синтаксис:

  ```C++
  #pragma omp sections [clause[ [ , ] clause] ... ]
    {
        [#pragma omp section]
          structured-block
        [#pragma omp section]
          structured-block
        ...
    }
  ```

* Здесь `clause` — это:
  * `private(list)` — задает список переменных, для которых порождается локальная копия в каждом потоке; начальное значение локальных копий переменных из списка не определено;
  * `firstprivate(list)` — задает список переменных, для которых порождается локальная копия в каждом потоке; локальные копии переменных инициализируются значениями этих переменных в потоке-мастере;
  * `lastprivate(list)` — переменным, перечисленным в списке, присваивается результат, полученный в последней секции;
  * `reduction(reduction-identifier : list)` — задает оператор и список общих переменных; для каждой переменной создаются локальные копии в каждом потоке; локальные копии инициализируются соответственно типу оператора; над локальными копиями перменных после завершения всех секций выполняется заданный оператор;
  * `nowait` - после выполнения выделенного участка происходит неявная барьерная синхронизация параллельно работающих потоков: их дальнейшее выполнение происходит только тогда, когда все они достигнут данной точки; если в подобной задержке нет необходимости, опция `nowait` позволяет потокам, уже дошедшим до конца участка, продолжить выполнение без синхронизации с остальными.

Директива `single`.

* Директива `single` используется, если в параллельной области какой-либо участок кода должен быть выполнен лишь один раз. Синтаксис:

  ```C++
  #pragma omp single [clause[ [ , ] clause] ... ]
    structured-block
  ```

* Здесь `clause` — это:
  * `private(list)` - задает список переменных, для которых порождается локальная копия в каждом потоке; начальное значение локальных копий переменных из списка не определено;
  * `firstprivate(list)` - задает список переменных, для которых порождается локальная копия в каждом потоке; локальные копии переменных инициализируются значениями этих переменных в потоке-мастере;
  * `copyprivate(list)` - после выполнения потока, содержащего конструкцию `single`, новые значения переменных списка будут доступны всем одноименным частным переменным, описанным в начале параллельной области и используемым всеми ее потоками; опция не может использоваться совместно с опцией `nowait`; переменные списка не должны быть перечислены в опциях `private` и `firstprivate` данной директивы `single`;
  * `nowait` - после выполнения выделенного участка происходит неявная барьерная синхронизация параллельно работающих потоков: их дальнейшее выполнение происходит только тогда, когда все они достигнут данной точки; если в подобной задержке нет необходимости, опция `nowait` позволяет потокам, уже дошедшим до конца участка, продолжить выполнение без синхронизации с остальными.

Директива `master`.

* Директива `master` выделяет участок кода, который будет выполнен только потоком-мастером. Синтаксис:

  ```C++
  #pragma omp master
    structured block
  ```

Директива `task`.

* Директива `task` применяется для выделения отдельной независимой задачи. Синтаксис:

  ```C++
  #pragma omp task [clause[ [ , ] clause] ... ]
    structured block
  ```

* Здесь `clause` — это:
  * `if(scalar-expression)` — порождение новой задачи только при выполнении некоторого условия; если условие не выполняется, то задача будет выполнена текущим потоком немедленно;
  * `final(scalar-expression)` — если верно `scalar-expression`, то у задачи нет предков и она помещается в общий пул; ее потомки будут или `final task`, или `included task` (задача начнет выполняться потоком немедленно);
  * `untied` — опция означает, что в случае откладывания задача может быть продолжена любым потоком из числа выполняющих данную параллельную область; если данная опция не указана, то задача может быть продолжена только породившим ее потоком;
  * `default(shared | none)` — всем переменным в задаче, которым явно не назначен класс, будет назначен класс shared; none означает, что всем переменным в задаче класс должен быть назначен явно;
  * `mergeable` — задача имеет ту же среду данных, что и область, в которой она была сгенерирована;
  * `private(list)` — задает список переменных, для которых порождается локальная копия в каждом потоке; начальное значение локальных копий переменных из списка не определено;
  * `firstprivate(list)` — задает список переменных, для которых порождается локальная копия в каждом потоке; локальные копии переменных инициализируются значениями этих перменных в потоке-мастере;
  * `shared(list)` — задает список переменных, общий для всех потоков;
  * `depend(dependence-type : list)` — в зависимости от `dependence-type` и того, что перечислено в `list` будут добавлены дополнительные ограничения на порядок выполнения задачи;
  * `priority(priority-value)` — среди всех задач, готовых к выполнению, будут выбираться задачи с более высоким значением `priority-value`.
