## Message Passing Interface (MPI). Существующие реализации, задачи MPI как среды программирования. Жизненный цикл MPI-программы. Создание и завершение MPI-процессов. Организация потока ввода-вывода, параметры, указываемые приложению, осуществляющему запуск MPI-программы. Группы и коммуникаторы в MPI.

Существует несколько реализаций библиотеки MPI, среди них известными являются OpenMPI и MPICH. При этом все реализации придерживаются общего стандарта.

Задачи MPI — предоставлять простой способ писать распределенные приложения. Философия: Single Progam, Multiple Data. Более того, MPI берет все выполнение на себя. Кроме того, MPI используется во многих других библиотеках как низкоуровневая часть.

Рассмотрим жизненный цикл программы MPI. Изначально исходный код компилируется некоторой главной машиной, далее (при начале исполнения) рассылается на вычислительные узлы и запускается средствами операционной системы, установленной на каждом узле кластера. При этом все узлы при запуске MPI-программы соединяются в общую группу, имеющую общий коммуникатор под названием `MPI_COMM_WORLD`. В начале каждой MPI-программы должен присутствовать вызов функции `MPI_Init(int argc, char** argv)`, который инициализирует параллельную часть программы и отвечает за создание общей группы для обмена сообщениями. В конце процесса общения должна быть вызвана функция `MPI_Finalize`, которая разрывает соединение между созданными группами и коммуникаторами.

Для начала поговорим о запуске программы, написанной при помощи MPI. Компиляция такой программы происходит при помощи приложений mpicc или mpic++ (в зависимости от того, любителем API С или С++ вы являетесь). Далее будет рассмотрен API для языка C (аналогичный API для C++, в целом, является схожим). Запуск программы происходит при помощи команды `mpirun`. При этом обычно указывается число узлов, на которых необходимо запустить программу (выполняется при помощи аргумента `-np`). Приблизительный пример запуска приложения на 4 узлах:

```bash
mpirun -np 4 ./a
```

Стандартный ввод-вывод в MPI организован следующим образом: `stdin` открыт только для процесса с рангом 0 (мастер), для остальных процессов стандартный поток ввода перенаправлен в `/dev/null`. Для того, чтобы изменить ситуацию, можно при запуске программы установить необходимое значение для аргумента, что подавать всем `stdin` или никому. В некоторых реализациях MPI возможно вместо опции подавать имя файла на ввод вместо ранговой характеристики.

Вывод работает на всех узлах, при этом главный узел сразу выводит необходимую информацию, а остальные узлы пересылают необходимую информацию на главный процесс, на котором и происходит вывод.

Программист может определять свои группы и коммуникаторы для связи между узлами из одной группы.

Группа — просто множество узлов, записанное в типе MPI_Group. Коммуникатор — комбинация из номера (чтобы различать коммуникаторы) и группы процессов. Общаться процессы могут только в пределах коммуникатора — два процесса между собой или один процесс со всеми в коммуникаторе. Изначально есть `MPI_COMM_WORLD`, в который входят все процессы. Программист может определять свои группы и коммуникаторы.

Основное API для управления группами и коммуникаторами.
* `int MPI_Comm_group(MPI_Comm comm, MPI_Group *group)` — для cоздания группы узлов из коммуникатора используется функция;
* Далее, для управления группами узлов используются функции добавление, исключения, объединения, пересечения и разности групп.
* Функции, необходимые для получения размер групп и коммуникаторов, получения ID узла в группах.
* Дублирование коммуникатора. После того, как определена группа узлов, необходимо создать соответственный коммуникатор.
* Если имеется некоторый коммуникатор, то при помощи выделенной группы можно создать новый коммуникатор посредством функции.
* Наконец, можно очистить созданные группы пользователей и коммуникаторы в конце работы.

В рассмотренном выше примере изначально создается группа {allNodes}, далее получается группа {workers} для работников. Наконец, создается дублирование коммуникатора {MPI_COMM_WORLD} с последствующим выделением нового коммуникатора, готового к работе.
