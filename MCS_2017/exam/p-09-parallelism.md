## Оценка распараллеливаемости программ. Виды зависимостей по данным между операторами в коде программы. Построенние графа зависимости по данным. Минимальный граф зависимостей по данным. Ширина яруса, критический путь — их влияние на общее время выполнения параллельной программы и выбор числа процессоров для распараллеливания. Проблема автоматического распараллеливания: что мешает.

Программа — это, прежде всего, множество ячеек памяти (переменных) и множество операторов, меняюющих эти ячейки. Переменные делятся два типа: входные (in) и выходные (out).

Если поймем, что операторы `s[1]`, `s[2]` и так далее можно менять местами без изменения результатов работы программы, то их можно будет безопасно распараллелить.

Оператор `s[i]` зависит от оператора `s[j]`, если оператор `s[j]` стоит до оператора `s[i]` (по коду) и множества рабочих переменных у этих операторов пересекаются.

Виды зависимостей.

* `in` от `in` — зависимости нет, можно параллелить. Пример:

  ```C++
  b = a;
  c = a;
  ```

* `out` от `in` — антизависимость, параллелить нельзя. Но можно переименовать регистры так, чтобы можно было параллелить. Пример:

  ```C++
    b = a;
    a = 1; // Переименуем в c.
  ```

* `in` от `out` — истинная заивисимость, паралльность невозможна. Пример:

  ```C++
    a = 1;
    b = a; // Не в таком простом случае, но суть ясна.
  ```

* `out` от `out`. Возможно, первое присваивание можно выбросить. Но иногда нельзя. Например, в случае, когда между присваиваниями выполняется функция, тело которой мы не знаем. В общем случае нам непонятнно, можно ли здесь переставлять. Пример:

  ```C++
    a = 1;
    a = 2;
  ```

По операторам можно построить граф зависимостей. Вершины — операторы. В графе есть ориентированное ребро `<s[j], s[i]>`, если `s[i]` зависит от `s[j]`.

Максимальное возможное время на выполнение программы, очевидно, есть длина самого длинного пути в этом графе (только сумма идет по весу вершин, а не весу ребер). Такой путь называется транзитным.

Критический путь — самый длинный по длительности вычислений от истока к стоку (исток —  ни от чего не зависит, сток — от него ничего не зависит).

Заметим, что граф зависимостей является ациклическим. Таким образом, он является деревом, а значит, можно оценить максимальное число процессоров, больше которого использовать не целесообразно. Оно определяется максимальной шириной яруса.

Кроме того, если в графе зависимостей есть транзитный путь между двумя вершинами (то есть самый долгий) и прямой, то прямой можно удалить, так как отношение зависимости является транзитивным: нет смысла хранить лишние ребра.

Про автоматическое распаллеливание: компилятор старается найти знакомые шаблоны, чтобы распараллелить эти куски кода. Следовательно, чем извращеннее написан код, тем хуже компилятор его распараллелит.
