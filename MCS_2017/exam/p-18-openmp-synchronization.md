## Синхронизация значений переменной с памятью. Критические секции. Конструкции и параметры в прагмах, определяющие синхронизхацию потоков в OpenMP-программе.

В OpenMP синхронизацию обеспечивают следующие директивы:

* `master`: `#pragma omp master` — директива *master* выделяет участок кода, который будет выполнен только потоком-мастером. Остальные потоки пропускают данный участок кода.

* `critical`: `#pragma omp critical [ name ]` — каждый момент времени в критической секции может находиться не более одного потока. Если критическая секция уже выполняется каким-то потоком, то все другие потоки, выполнившие директиву для секции с данным именем, будут заблокированы, пока вошедший поток не закончит выполнение данной критической секции. Как только работавший поток выйдет из критической секции, один из заблокированных на входе потоков войдет в нее. Если на входе в критическую секцию стояло несколько потоков, то случайным образом выбирается один из них, а остальные заблокированные потоки продолжают ожидание. Все неименованные критические секции условно ассоциируются с одним и тем же именем. Все критические секции, имеющие одно и то же имя, рассматриваются единой секцией, даже если находятся в разных параллельных областях.

* `barrier`: `#pragma omp barrier` — потоки, выполняющие текущую параллельную область, дойдя до этой директивы, останавливаются и ждут, пока все потоки не дойдут до этой точки программы, после чего разблокируются и продолжают работать дальше. Кроме того, для разблокировки необходимо, чтобы все синхронизируемые потоки завершили все порожденные ими задачи.

* `taskwait`: `#pragma omp taskwait` — выполнение текущей области будет приостановлено до тех пор, пока не завершатся все задачи, начатые до того, как встретилась `taskwait`-директива.

* `atomic`: `#pragma omp atomic` — данная директива относится к идущему непосредственно за ней оператору присваивания, гарантируя корректную работу с общей переменной, стоящей в его левой части. На время выполнения оператора блокируется доступ к данной переменной всем запущенным в данный момент потокам, кроме потока, выполняющего операцию. Атомарной является только работа с переменной в левой части оператора присваивания, при этом вычисления в правой части не обязаны быть атомарными.

* `flush`: `#pragma omp flush [ list ]` — выполнение данной директивы предполагает, что значения всех переменных из списка, временно хранящиеся в регистрах и кэш-памяти текущего потока, будут занесены в основную память; все изменения переменных, сделанные потоком во время работы, станут видимыми остальным потокам; если какая-то информация хранится в буферах вывода, то буферы будут сброшены. При этом операция производится только с данными вызвавшего потока, данные, изменявшиеся другими потоками, не затрагиваются. До полного завершения операции никакие действия с перечисленными в ней переменными не могут начаться.

* `ordered`: `#pragma omp ordered` — директива `ordered` определяет блок внутри тела цикла, который должен выполняться в том порядке, в котором итерации идут в последовательном цикле. Потоки ждут, пока не будут выполнены предыдущие итерации. Используется внутри цикла, запущенного с директивой `ordered`.

* `threadprivate`: `#pragma omp threadprivate ([ list ])` — директива `threadprivate` применяется к глобальным перменным программы, которые нужно сделать локальными для каждого из параллельных потоков.

OpenMP API предоставляет возможность работы с локами.

Лок может находиться в одном из трех состояний: неинициализированный, разблокированный или заблокированный. Разблокированный лок может быть захвачен некоторым потоком. При этом он переходит в заблокированное состояние. Поток, захвативший лок, и только он может его осовободить, после чего лок возвращается в разблокированное состояние.

Есть два типа локов: простые и множественные. Множественный лок может многократно захватываться одним потоком перед его освобождением, в то время как простой лок может быть захвачен только однажды. Для множественного лока вводится понятие коэффициента захваченности. Изначально он равен нулю, при каждом следующем захватывании увеличивается на единицу, а при каждом освобождении уменьшается на единицу. Множественный лок считается разблокированным, если его коэффициент захваченности равен нулю.

_Инициализация_:
* `void omp_init_lock(omp_lock_t *lock);`
* `void omp_init_nest_lock(omp_nest_lock_t *lock);`

_Уничтожение (перевод в неинициализированное состояние)_:
* `void omp_destroy_lock(omp_lock_t *lock);`
* `void omp_destroy_nest_lock(omp_nest_lock_t *lock);`

_Захват_:
* `void omp_set_lock(omp_lock_t *lock);`
* `void omp_set_nest_lock(omp_nest_lock_t *lock);`

_Освобождение_:
* `void omp_unset_lock(omp_lock_t *lock);`
* `void omp_unset_nest_lock(omp_lock_t *lock);`
