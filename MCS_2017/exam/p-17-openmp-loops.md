## Работа с циклами в OpenMP, указываемые параметры при создании. Параметр, задающий расписание исполнения итераций. Параметр, задающий распределеннную операцию.

Если в параллельной области встретился оператор цикла, то он будет выполнен всеми потоками текущей группы, то есть каждый поток выполнит все итерации данного цикла. Для распределения итераций цикла между различными потоками можно использовать директиву `#pragma omp for`. Синтаксис:

```C++
#pragma omp for [clause [ [ , ] clause] ... ]
  for-loops
```

Здесь `clause` — это:
* `private(list)` — задает список переменных, для которых порождается локальная копия в каждом потоке; начальное значение локальных копий переменных из списка не определено;
* `firstprivate(list)` — задает список переменных, для которых порождается локальная копия в каждом потоке; локальные копии переменных инициализируются значениями этих перменных в потоке-мастере;
* `lastprivate(list)` — переменным, перечисленным в списке, присваивается результат, полученный в последней итерации цикла;
* `linear(list [ : linear-step])` — переменные, перечисленные в списке, будут `private` в соответсвтующе; *SIMD la;e* и будут линейно зависимы в пространстве итераций цикла;
* `reduction(reduction-identifier : list)` — задает оператор и список общих переменных; для каждой переменной создаются локальные копии в каждом потоке; локальные копии инициализируются соответственно типу оператора; над локальными копиями перменных после завершения всех секций выполняется заданный оператор;
* `schedule(kind [, chunk_size])` — опция задает, каким образом итерации цикла распределеяются между потоками;
* `collapse(n)` — опция указывает, что `n` последовательных тесновложенных циклов ассоциируются с данной директивой; для циклов образуется общее пространство итераций, которое делится между потоками; если опция `collapse` не задана, то директива относится только к одному непосредственно следующему за ней циклу;
* `ordered` — опция, говорящяя о том, что в цикле могут встречаться директивы `ordered`; в этом случае определяется блок внутри тела цикла, который должен выполняться в том порядке, в котором итерации идут в последовательном цикле;
* `nowait` — в конце параллельного цикла происходит неявная барьерная синхронизация параллельно работающих потоков: их дальнейшее выполнение происходит только тогда, когда все они достигнут данной точки; если в подобной задержке нет необходимости, опция `nowait` позволяет потокам, уже дошедшим до конца цикла, продолжить выполнение без синхронизации с остальными.
