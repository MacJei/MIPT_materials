## Определение консенсуса, три его свойства. Альтернативные формулировки консенсуса: Terminating Reliable Broadcast, Weak Interactive Consistency. Их эквивалентность.

### Постановка задачи.

В каких условиях будем работать.
* Пусть есть _n_ процессов и разрешено отказывать не более чем _f_ из них.
* Запретим процессам подниматься после падения. Если мы, например, докажем невозможность чего-нибудь, то скорее всего, это будет верно и в системе, где процессы могут возобновлять работу.
* Разрешим отказы только типа Crash (и Fail-Stop, в частности).
* Допускается падение процесса в середине логического шага и (например) отправить часть сообщений из планируемых.
* В асинхронной системе невозможно отличить, получатель сломан или сообщение еще не доставлено.
* Сеть надежна, то есть не теряет сообщения.
* Есть полная связность процессов (между любой парой процессов есть прямой канал связи).

_Значением консенсуса_ будем считать _Boolean_ или любой другой тип.

Система состоит из _n_ процессов, и не более _f_ процессов могут испытать отказ класса _ψ_ (не возобновляя работу). Каждый процесс получает на ввод значение. Все исправные процессы должны выбрат одно число из предложенных, удовлетворяя трем свойствам:

* (**argeement**) Все исправные процессы выбирают одно и то же число.
* (**validity**) Процессы выбирают число из предложенных.
* (**termination**) Каждый исправный процесс рано или поздно примет решение.

Простое решение при _f = 0_:
* процесс рассылает всем свое значение и принимает значения других процессов, складывая их в `values`;
* когда процесс знает значения всех остальных процессов, он принимает решение `min(values)` (или другую детерминированную агрегатную функцию, например, `max`, `majority` и т. п.);
* этот алгоритм корректен, так как отказов нет, а значит, все сообщения рано или поздно будут получены.

Пример другой задачи: _k_-консенсус при _k = 1_. Разрешим одному процессу упасть, но при этом остальные должны вернуть два числа, чтобы среди этих двух было хотя бы одно общее. Здесь почти точно так же можно: когда накопим _n - 1_ число, возвращаем `min` и `second-min`. Так как пропущено не более одного числа, то один из двух минимумом будет точно правильным.

### Альтернативные формулировки

* **Terminating Reliable Broadcast**, или The Byzantine Agreement Problem.

  Есть выделенный процесс _G_, у которого есть начальное значение _I_. И есть _n_ процессов _p_i_.

  * (argeement) Все исправные процессы выбирают одно и то же число.
  * (validity) Если _G_ исправен, то все исправные процессы решают значение _I_.
  * (termination) Каждый исправный процесс рано или поздно примет решение.

* **Weak Interactive Consistency**.

  Есть _n_ процессов, каждый из которых имеет начальное значение _v_i_.

  * (argeement) Все исправные процессы выбирают один и тот же вектор _**v**_.
  * (validity) Если _p_i_ исправен, то _**v**\_i = v_i_, иначе любое число.
  * (termination) Каждый исправный процесс рано или поздно примет решение.

Идея доказательства эквивалентности: нужно свести одну задачу к другой, то по решению первой задачи построить решение второй, и наоборот.

### Разрешимость консенсуса

Пусть _n_ — общее число процессов, и допускается падение _f_ из них. Тогда условия на разрешимость консенсуса:

тип отказа  | SMP, SSM                      | AMP, ASM
----------- | ----------------------------- | -----------
без отказов | разрешим                      | разрешим
Crash       | разрешим при f <= n - 1       | не разрешим
Byzantine   | разрешим при f <= (n - 1) / 3 | не разрешим
